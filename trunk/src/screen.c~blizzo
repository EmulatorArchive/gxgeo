#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <gccore.h>
#include <wiiuse/wpad.h>
#include <sys/time.h>
#define TICKS_PER_SEC 1000000UL

#include "screen.h"
#include "emu.h"
#include "video.h"
#include "conf.h"

	unsigned int *xfb[2];
	int whichfb = 0;
	GXRModeObj *vmode;

	#define TEX_WIDTH 352
	//#define TEX_WIDTH 352
	#define TEX_HEIGHT 256
	//#define TEX_HEIGHT 256
	#define DEFAULT_FIFO_SIZE 256 * 1024

	static u8 gp_fifo[DEFAULT_FIFO_SIZE] ATTRIBUTE_ALIGN (32);
	static u8 texturemem[TEX_WIDTH * TEX_HEIGHT * 2] ATTRIBUTE_ALIGN (32);
	GXTexObj texobj;
	static Mtx view;
	int vwidth, vheight, oldvwidth, oldvheight;

	#define HASPECT 304/4.1 /* here? */
	#define VASPECT 304/4.1
	typedef struct tagcamera
	{
		Vector pos;
		Vector up;
		Vector view;
	} camera;

	s16 square[] ATTRIBUTE_ALIGN (32) =
	{
		/*
		* X,   Y,  Z
		* Values set are for roughly 4:3 aspect
		*/
		-HASPECT, 	VASPECT, 	0,	// 0
		HASPECT, 	VASPECT, 	0,	// 1
		HASPECT, 	-VASPECT, 	0,	// 2
		-HASPECT, 	-VASPECT, 	0,	// 3
	};

	static camera cam = {
		{0.0F, 0.0F, 0.0F},
		{0.0F, 0.5F, 0.0F},
		{0.0F, 0.0F, -0.5F}
	};


	static bool draw_init (void)
	{
		GX_ClearVtxDesc ();
		GX_SetVtxDesc (GX_VA_POS, GX_INDEX8);
		GX_SetVtxDesc (GX_VA_CLR0, GX_INDEX8);
		GX_SetVtxDesc (GX_VA_TEX0, GX_DIRECT);
		GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_POS, GX_POS_XYZ, GX_S16, 0);
		GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_CLR0, GX_CLR_RGBA, GX_RGBA8, 0);
		GX_SetVtxAttrFmt (GX_VTXFMT0, GX_VA_TEX0, GX_TEX_ST, GX_F32, 0);
		GX_SetArray (GX_VA_POS, square, 3 * sizeof (s16));
		GX_SetNumTexGens (1);
		GX_SetTexCoordGen (GX_TEXCOORD0, GX_TG_MTX2x4, GX_TG_TEX0, GX_IDENTITY);
		GX_InvalidateTexAll ();
		GX_InitTexObj (&texobj, texturemem, vwidth, vheight, GX_TF_RGB565, GX_CLAMP, GX_CLAMP, GX_FALSE);
	}

	static void draw_vert (u8 pos, u8 c, f32 s, f32 t)
	{
		GX_Position1x8 (pos);
		GX_Color1x8 (c);
		GX_TexCoord2f32 (s, t);
	}

	static void draw_square (Mtx v)
	{
		Mtx m;			// model matrix.
		Mtx mv;			// modelview matrix.

		guMtxIdentity (m);
		guMtxTransApply (m, m, 0, -14, -100);
		guMtxConcat (v, m, mv);
		GX_LoadPosMtxImm (mv, GX_PNMTX0);
		GX_Begin (GX_QUADS, GX_VTXFMT0, 4);
		draw_vert (0, 0, 0.0, 0.0);
		draw_vert (1, 0, 1.0, 0.0);
		draw_vert (2, 0, 1.0, 1.0);
		draw_vert (3, 0, 0.0, 1.0);
		GX_End ();
	}

	
	/*** 
		Video Update
			called after each emulation frame
	***/
	static void blitter_gx_update()
	{
		int h, w;
		vwidth 	= buffer.viewport.w;
		vheight = buffer.viewport.h;
		
		long long int *dst  = (long long int *)texturemem;
		long long int *src1 = (long long int *)( buffer.data + (buffer.viewport.x*buffer.granularity) + (buffer.viewport.y*buffer.pitch) );
		//long long int *src1 = (long long int *)( buffer.data );
		long long int *src2 = src1 + (buffer.width>>2);
		long long int *src3 = src2 + (buffer.width>>2);
		long long int *src4 = src3 + (buffer.width>>2);

		whichfb ^= 1;

		if ((oldvheight != vheight) || (oldvwidth != vwidth))
		{
			/** Update scaling **/
			oldvwidth = vwidth;
			oldvheight = vheight;
			draw_init();
			memset (&view, 0, sizeof (Mtx));
			guLookAt(view, &cam.pos, &cam.up, &cam.view);
			GX_SetViewport (0, 0, vmode->fbWidth, vmode->efbHeight, 0, 1);
		}

		GX_InvVtxCache ();
		GX_InvalidateTexAll ();
		GX_SetTevOp (GX_TEVSTAGE0, GX_DECAL);
		GX_SetTevOrder (GX_TEVSTAGE0, GX_TEXCOORD0, GX_TEXMAP0, GX_COLOR0A0);

		for (h = 0; h < vheight; h += 4) {
			for (w = 0; w < (vwidth >> 2); w++ ) {
				*dst++ = *src1++;
				*dst++ = *src2++;
				*dst++ = *src3++;
				*dst++ = *src4++;
			}

			src1 += (buffer.viewport.x>>1) + buffer.width; // ((buffer.viewport.x * 2) / 4 ) + buffer.width;
			src2 += (buffer.viewport.x>>1) + buffer.width;
			src3 += (buffer.viewport.x>>1) + buffer.width;
			src4 += (buffer.viewport.x>>1) + buffer.width;
		}

		DCFlushRange (texturemem, TEX_WIDTH * TEX_HEIGHT * 2);
		GX_SetNumChans (1);
		GX_LoadTexObj (&texobj, GX_TEXMAP0);
		draw_square (view);
		GX_DrawDone ();
		GX_SetZMode (GX_TRUE, GX_LEQUAL, GX_TRUE);
		GX_SetColorUpdate (GX_TRUE);
		GX_CopyDisp (xfb[whichfb], GX_TRUE);
		GX_Flush ();
		VIDEO_SetNextFramebuffer (xfb[whichfb]);
		VIDEO_Flush ();
	}


	void gx_shutdown(void)
	{
		printf("Quitting...");
	}

	/*** StartGX
		This function initialises the GX.
		WIP3 - Based on texturetest from libOGC examples.
	***/
	static void StartGX (void)
	{
		Mtx p;
		GXColor gxbackground = { 0, 0, 0, 0xff };

		/*** Clear out FIFO area ***/
		memset (&gp_fifo, 0, DEFAULT_FIFO_SIZE);

		/*** Initialise GX ***/
		GX_Init (&gp_fifo, DEFAULT_FIFO_SIZE);
		GX_SetCopyClear (gxbackground, 0x00ffffff);
		GX_SetViewport (0, 0, vmode->fbWidth, vmode->efbHeight, 0, 1);
		GX_SetDispCopyYScale ((f32) vmode->xfbHeight / (f32) vmode->efbHeight);
		GX_SetScissor (0, 0, vmode->fbWidth, vmode->efbHeight);
		GX_SetDispCopySrc (0, 0, vmode->fbWidth, vmode->efbHeight);
		GX_SetDispCopyDst (vmode->fbWidth, vmode->xfbHeight);
		GX_SetCopyFilter (vmode->aa, vmode->sample_pattern, GX_TRUE, vmode->vfilter);
		GX_SetFieldMode (vmode->field_rendering, ((vmode->viHeight == 2 * vmode->xfbHeight) ? GX_ENABLE : GX_DISABLE));
		GX_SetPixelFmt (GX_PF_RGB8_Z24, GX_ZC_LINEAR);
		GX_SetCullMode (GX_CULL_NONE);
		GX_CopyDisp (xfb[whichfb ^ 1], GX_TRUE);
		GX_SetDispCopyGamma (GX_GM_1_0);
		guPerspective (p, 60, 1.33F, 10.0F, 1000.0F);
		GX_LoadProjectionMtx (p, GX_PERSPECTIVE);
		//guOrtho(p,0,479,0,639,0,300);
		//GX_LoadProjectionMtx(p, GX_ORTHOGRAPHIC);
		memset (texturemem, 0, TEX_WIDTH * TEX_HEIGHT * 2);
		vwidth = 100;
		vheight = 100;
	}

	void gx_video_init(void) {
		VIDEO_Init ();


		/*
		* Reset the video mode
		* This is always set to 60hz
		* Whether your running PAL or NTSC
		*/
		vmode = VIDEO_GetPreferredMode(NULL);
		VIDEO_Configure (vmode);

		/*** Now configure the framebuffer.
				Really a framebuffer is just a chunk of memory
				to hold the display line by line.
		**/
		xfb[0] = (u32 *) MEM_K0_TO_K1((u32 *) SYS_AllocateFramebuffer(vmode));

		/*** I prefer also to have a second buffer for double-buffering.
				This is not needed for the console demo.
		***/
		xfb[1] = (u32 *) MEM_K0_TO_K1((u32 *) SYS_AllocateFramebuffer(vmode));

		/*** Define a console ***/
		console_init(xfb[0], 20, 64, vmode->fbWidth, vmode->xfbHeight, vmode->fbWidth * 2);

		/*** Clear framebuffer to black ***/
		VIDEO_ClearFrameBuffer(vmode, xfb[0], COLOR_BLACK);
		VIDEO_ClearFrameBuffer(vmode, xfb[1], COLOR_BLACK);

		/*** Set the framebuffer to be displayed at next VBlank ***/
		VIDEO_SetNextFramebuffer(xfb[0]);

		/*** Increment frameticker and timer ***/
		//VIDEO_SetPreRetraceCallback(framestart);

		/*** Get the PAD status updated by libogc ***/
		VIDEO_SetPostRetraceCallback(PAD_ScanPads);
		//VIDEO_SetPostRetraceCallback(WPAD_ScanPads);
		VIDEO_SetBlack (FALSE);

		/*** Update the video for next vblank ***/
		VIDEO_Flush();

		/*** Wait for VBL ***/
		VIDEO_WaitVSync();
		if (vmode->viTVMode & VI_NON_INTERLACE) VIDEO_WaitVSync();

		StartGX ();

	}


bool screen_init()
{
	gx_video_init();
	return true;
}


void screen_update()
{
	blitter_gx_update();
}

void screen_close()
{

}

